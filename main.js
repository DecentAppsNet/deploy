import ht from"path";async function V(t,e){let o=t.length,n=[...t];return new Promise((s,r)=>{function a(u){u().then(()=>{if(--o===0){s();return}if(n&&n.length){let c=n.pop();c&&a(c)}}).catch(c=>r(c))}let i=Math.min(e,t.length);for(let u=0;u<i;++u){let c=n.pop();c&&a(c)}}).catch(s=>{throw s})}function tt(t){return/^[0-9a-f]{7}$/i.test(t)}function et(t){return/^[0-9a-f]{40}$/i.test(t)}function T(t){return tt(t)||et(t)}function O(t){return t.length>7?t.slice(0,7):t}var v=class extends Error{constructor(e){super(e),this.name="ExpectedError"}},l=v;function ot(t){console.error(`::error::${t}`)}function y(t){console.warn(`::warning::${t}`)}function nt(t){console.log(`::notice::${t}`)}function A(t){nt(`\u2705 ${t}`)}function p(t){console.log(t)}function w(t){ot(t),process.exit(1)}function h(t){console.log(`::group::${t}`)}function m(){console.log("::endgroup::")}function $(t,e=!1){let o=`INPUT_${t.replace(/ /g,"_").toUpperCase()}`,n=process.env[o];return e&&!n&&w(`Input ${t} is required.`),n||""}function _(){let t=process.env.GITHUB_SHA;if(!t)throw new l("GITHUB_SHA environment variable is not set.");if(!T(t))throw new l("GITHUB_SHA environment variable is invalid.");return O(t)}function F(){let t=process.env.GITHUB_REPOSITORY_OWNER;if(!t)throw new l("GITHUB_REPOSITORY_OWNER environment variable is not set.");return t}function I(){let t=process.env.GITHUB_WORKSPACE;if(!t)throw new l("GITHUB_WORKSPACE environment variable is not set.");return t}function k(){return process.env.GITHUB_ACTIONS==="true"}import{opendir as rt,stat as st,mkdir as Rt}from"fs/promises";import{createReadStream as St,createWriteStream as it}from"fs";import U from"path";async function q(t){let e=[];async function o(n){let s=await rt(n);for await(let r of s){let a=U.join(n,r.name);r.isDirectory()?await o(a):e.push(a)}}return await o(t),e}async function H(t){try{return(await st(t)).isDirectory()}catch{return!1}}async function at(t,e){return new Promise((o,n)=>{let s=it(t);s.write(e),s.end(),s.on("finish",()=>o()),s.on("error",r=>n(r))}).catch(o=>{throw o})}async function ct(t,e){return at(t,e)}async function L(t,e){let o=U.join(e,"version.txt");return await ct(o,t)}import*as C from"node:https";import{createReadStream as ut}from"fs";import{stat as pt}from"fs/promises";async function B(t,e){let o=await pt(e);return new Promise((n,s)=>{t.headers||(t.headers={}),t.headers["Content-Length"]=o.size;let r=C.request(t,i=>{let u="";i.on("data",c=>{u+=c}),i.on("end",async()=>{i.statusCode&&i.statusCode>=200&&i.statusCode<300?n({statusCode:i.statusCode,body:u}):s(new l(`Request to ${t.hostname} failed with status code: ${i.statusCode}. Response: ${u}`))})});r.on("error",i=>s(i));let a=ut(e);a.pipe(r),a.on("end",()=>r.end()),a.on("error",i=>{r.destroy(),s(i)})}).catch(n=>{throw n})}async function D(t,e){return new Promise((o,n)=>{t.headers||(t.headers={}),t.headers["Content-Length"]=Buffer.byteLength(e);let s=C.request(t,r=>{let a="";r.on("data",i=>{a+=i}),r.on("end",async()=>{r.statusCode&&r.statusCode>=200&&r.statusCode<300?o({statusCode:r.statusCode,body:a}):n(new l(`Request to ${t.hostname} failed with status code: ${r.statusCode}. Response: ${a}`))})});s.on("error",r=>n(r)),s.write(e),s.end()}).catch(o=>{throw o})}var P="1.0",G=`v${P} Decent Tools`;function lt(t){let e="<!-- v",o=t.indexOf(e);if(o===-1)return null;let n=o+e.length,s=t.indexOf(" ",n);return s===-1?null:t.substring(n,s)}function R(t,e){let o=` ${e}='`,n=t.indexOf(o);if(n===-1)return null;let s=n+o.length,r=t.indexOf("'",s);return r===-1?null:t.substring(s,r)}function dt(t){let e=lt(t);if(!e)throw Error("Failed to parse stage index format version.");if(e!==P)throw Error(`Unsupported stage index format version ${e}.`);return e}function N(){return{productionVersion:"",rollbackVersion:"",stageVersion:""}}function W(t,e,o,n){let s=`/_${t}/${e}/`;return`<!DOCTYPE html><html><head><title>Stage Index for ${t}</title><script>
<!-- ${G}. Hand-edit at your own risk! -->
const productionVersion='${o}';
const rollbackVersion='${n}';
const stageVersion='${e}';
window.location.href='${s}';
</script></head><body></body></html>`}async function j(t){let e=`https://decentapps.net/_${t}/index.html`,o=await fetch(e);if(!o.ok)return N();let n=await o.text();try{dt(n)}catch(i){return y(`Could not retrieve app versions from existing stage index at ${e}: ${i.message}.`),N()}let s=R(n,"productionVersion")??"",r=R(n,"rollbackVersion")??"";return{stageVersion:R(n,"stageVersion")??"",productionVersion:s,rollbackVersion:r}}var M="partner.decentapps.net";async function Y(t,e,o,n,s,r){let a=r.replace(s,""),i={hostname:M,path:`/api/deployment/${o}/${n}/${a}`,port:443,method:"PUT",headers:{"Content-Type":"application/octet-stream",Authorization:`Bearer ${e}`,"x-repo-owner":t,Accept:"application/json"}},u=await B(i,r);if(u.statusCode<200||u.statusCode>=300)throw new l(`Failed to upload file to partner service. Status code: ${u.statusCode}. Response: ${u.body}`)}async function z(t,e,o,n,s,r,a){let i=a?`/api/deployment/${o}/index.html`:`/api/deployment/${o}/index.html?updateRoute=true`,u={hostname:M,path:i,port:443,method:"PUT",headers:{"Content-Type":"text/html",Authorization:`Bearer ${e}`,"x-repo-owner":t,Accept:"application/json"}},c=W(o,n,s,r),g=await D(u,c);if(g.statusCode<200||g.statusCode>=300)throw new Error(`Failed to upload file to partner service. Status code: ${g.statusCode}. Response: ${g.body}`)}import{readFile as ft}from"fs/promises";import gt from"path";async function K(t){let e=await fetch(`https://raw.githubusercontent.com/DecentAppsNet/${t}/refs/heads/main/version.txt`);if(!e.ok)throw new Error(`Failed to fetch action version: ${e.statusText}`);return(await e.text()).trim()}async function X(){try{let t=gt.join(__dirname,"version.txt");return console.log(`Reading local action version from ${t}`),(await ft(t,"utf8")).trim()}catch(t){throw new Error(`Failed to read local action version: ${t.message}`)}}async function mt(){try{h("Checking action version"),p("fetch local action version");let t=await X();p("fetch latest action version");let e=await K("deploy");t!==e?y(`Local action version ${t} does not match latest action version ${e}. Consider updating your action.`):p(`Local action version ${t} matches latest action version.`),m(),h("Collecting inputs"),p("commit hash");let o=_();p("repo owner");let n=F();p("Decent API key");let s=$("api-key",!0);p("app name");let r=$("app-name",!0);p("project local path");let a=I();m(),h("Preparing local dist path and version file"),p("check for dist directory");let i=ht.join(a,"dist");await H(i)||w("Local dist directory missing. Your Github workflow (e.g., .github/workflows/deploy.yml) should check out your project and build/copy to the ./dist folder all files meant for deployment."),p("write version file"),await L(o,i),m(),h("Preparing files for upload");async function u(f){let d=c[f];if(d!=="")try{p(`upload ${d}`),await Y(n,s,r,o,i,d),c[f]="",++x}catch(Z){console.warn(`Failed to upload file ${d}: ${Z.message}.`)}}p("find files at local dist path");let c=await q(i);c.length===1&&y("No files found in ./dist directory besides version.txt. Is your project building to ./dist?"),p("prepare upload tasks");let g=c.map((f,d)=>()=>u(d));m(),h(`Uploading ${g.length} files`);let x=0,b=3,J=10;for(let f=0;f<b;++f){f>0&&console.warn(`Retrying after failed uploads... (${f+1}/${b})`);try{if(await V(g,J),x===c.length)break}catch(d){d(`Unexpected error while uploading files: ${d.message}.`)}}x<c.length&&(x===0&&w("Failed to upload any files. See previous warnings for details."),w(`Failed to upload all files. Only ${x} of ${c.length} files were uploaded successfully. See previous warnings for details.`)),m(),h("Updating stage index"),p("fetch app versions");let{productionVersion:S,rollbackVersion:E}=await j(r);p(`uploading new stage index - stage version=${o}, production version=${S}, rollback version=${E}`),await z(n,s,r,o,S,E,!1),m();let Q=`https://decentapps.net/_${r}/${o}/`;A(`Successfully deployed ${x} files to ${Q}.`)}catch(t){let o=!k()||t.name==="ExpectedError"?t.message:"An unexpected error occurred.";w(o)}}mt();
