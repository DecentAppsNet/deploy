import wt from"path";async function T(t,e){let o=t.length,n=[...t];return new Promise((s,r)=>{function a(p){p().then(()=>{if(--o===0){s();return}if(n&&n.length){let c=n.pop();c&&a(c)}}).catch(c=>r(c))}let i=Math.min(e,t.length);for(let p=0;p<i;++p){let c=n.pop();c&&a(c)}}).catch(s=>{throw s})}function et(t){return/^[0-9a-f]{7}$/i.test(t)}function ot(t){return/^[0-9a-f]{40}$/i.test(t)}function V(t){return et(t)||ot(t)}function O(t){return t.length>7?t.slice(0,7):t}var v=class extends Error{constructor(e){super(e),this.name="ExpectedError"}},l=v;function nt(t){console.error(`::error::${t}`)}function y(t){console.warn(`::warning::${t}`)}function rt(t){console.log(`::notice::${t}`)}function A(t){rt(`\u2705 ${t}`)}function u(t){console.log(t)}function w(t){nt(t),process.exit(1)}function g(t){console.log(`::group::${t}`)}function m(){console.log("::endgroup::")}function $(t,e=!1){let o=`INPUT_${t.replace(/ /g,"_").toUpperCase()}`,n=process.env[o];return e&&!n&&w(`Input ${t} is required.`),n||""}function F(){let t=process.env.GITHUB_SHA;if(!t)throw new l("GITHUB_SHA environment variable is not set.");if(!V(t))throw new l("GITHUB_SHA environment variable is invalid.");return O(t)}function I(){let t=process.env.GITHUB_REPOSITORY_OWNER;if(!t)throw new l("GITHUB_REPOSITORY_OWNER environment variable is not set.");return t}function _(){let t=process.env.GITHUB_WORKSPACE;if(!t)throw new l("GITHUB_WORKSPACE environment variable is not set.");return t}function k(){return process.env.GITHUB_ACTIONS==="true"}import{opendir as st,stat as it,mkdir as Et}from"fs/promises";import{createReadStream as Vt,createWriteStream as at}from"fs";import U from"path";async function q(t){let e=[];async function o(n){let s=await st(n);for await(let r of s){let a=U.join(n,r.name);r.isDirectory()?await o(a):e.push(a)}}return await o(t),e}async function H(t){try{return(await it(t)).isDirectory()}catch{return!1}}async function ct(t,e){return new Promise((o,n)=>{let s=at(t);s.write(e),s.end(),s.on("finish",()=>o()),s.on("error",r=>n(r))}).catch(o=>{throw o})}async function pt(t,e){return ct(t,e)}async function L(t,e){let o=U.join(e,"version.txt");return await pt(o,t)}import*as C from"node:https";import{createReadStream as ut}from"fs";import{stat as lt}from"fs/promises";async function B(t,e){let o=await lt(e);return new Promise((n,s)=>{t.headers||(t.headers={}),t.headers["Content-Length"]=o.size;let r=C.request(t,i=>{let p="";i.on("data",c=>{p+=c}),i.on("end",async()=>{i.statusCode&&i.statusCode>=200&&i.statusCode<300?n({statusCode:i.statusCode,body:p}):s(new l(`Request to ${t.hostname} failed with status code: ${i.statusCode}. Response: ${p}`))})});r.on("error",i=>s(i));let a=ut(e);a.pipe(r),a.on("end",()=>r.end()),a.on("error",i=>{r.destroy(),s(i)})}).catch(n=>{throw n})}async function D(t,e){return new Promise((o,n)=>{t.headers||(t.headers={}),t.headers["Content-Length"]=Buffer.byteLength(e);let s=C.request(t,r=>{let a="";r.on("data",i=>{a+=i}),r.on("end",async()=>{r.statusCode&&r.statusCode>=200&&r.statusCode<300?o({statusCode:r.statusCode,body:a}):n(new l(`Request to ${t.hostname} failed with status code: ${r.statusCode}. Response: ${a}`))})});s.on("error",r=>n(r)),s.write(e),s.end()}).catch(o=>{throw o})}var P="1.0",G=`v${P} Decent Tools`;function dt(t){let e="<!-- v",o=t.indexOf(e);if(o===-1)return null;let n=o+e.length,s=t.indexOf(" ",n);return s===-1?null:t.substring(n,s)}function R(t,e){let o=` ${e}='`,n=t.indexOf(o);if(n===-1)return null;let s=n+o.length,r=t.indexOf("'",s);return r===-1?null:t.substring(s,r)}function ft(t){let e=dt(t);if(!e)throw Error("Failed to parse stage index format version.");if(e!==P)throw Error(`Unsupported stage index format version ${e}.`);return e}function N(){return{productionVersion:"",rollbackVersion:"",stageVersion:""}}function W(t,e,o,n){let s=`/_${t}/${e}/`;return`<!DOCTYPE html><html><head><title>Stage Index for ${t}</title><script>
<!-- ${G}. Hand-edit at your own risk! -->
const productionVersion='${o}';
const rollbackVersion='${n}';
const stageVersion='${e}';
window.location.href='${s}';
</script></head><body></body></html>`}async function j(t){let e=`https://decentapps.net/_${t}/index.html`,o=await fetch(e);if(!o.ok)return N();let n=await o.text();try{ft(n)}catch(i){return y(`Could not retrieve app versions from existing stage index at ${e}: ${i.message}.`),N()}let s=R(n,"productionVersion")??"",r=R(n,"rollbackVersion")??"";return{stageVersion:R(n,"stageVersion")??"",productionVersion:s,rollbackVersion:r}}var M="partner.decentapps.net";async function Y(t,e,o,n,s,r){let a=r.replace(s,""),i={hostname:M,path:`/api/deployment/${o}/${n}/${a}`,port:443,method:"PUT",headers:{"Content-Type":"application/octet-stream",Authorization:`Bearer ${e}`,"x-repo-owner":t,Accept:"application/json"}},p=await B(i,r);if(p.statusCode<200||p.statusCode>=300)throw new l(`Failed to upload file to partner service. Status code: ${p.statusCode}. Response: ${p.body}`)}async function z(t,e,o,n,s,r,a){let i=a?`/api/deployment/${o}/index.html`:`/api/deployment/${o}/index.html?updateRoute=true`,p={hostname:M,path:i,port:443,method:"PUT",headers:{"Content-Type":"text/html",Authorization:`Bearer ${e}`,"x-repo-owner":t,Accept:"application/json"}},c=W(o,n,s,r),h=await D(p,c);if(h.statusCode<200||h.statusCode>=300)throw new Error(`Failed to upload file to partner service. Status code: ${h.statusCode}. Response: ${h.body}`)}import{readFile as ht}from"fs/promises";import{fileURLToPath as gt}from"url";import K from"path";var mt=gt(import.meta.url),xt=K.dirname(mt);async function X(t){let e=await fetch(`https://raw.githubusercontent.com/DecentAppsNet/${t}/refs/heads/main/version.txt`);if(!e.ok)throw new Error(`Failed to fetch action version: ${e.statusText}`);return(await e.text()).trim()}async function J(){try{let t=K.join(xt,"version.txt");return(await ht(t,"utf8")).trim()}catch(t){throw new Error(`Failed to read local action version: ${t.message}`)}}async function yt(){try{g("Checking action version"),u("fetch local action version");let t=await J();u("fetch latest action version");let e=await X("deploy");t!==e?y(`Local action version ${t} does not match latest action version ${e}. Consider updating your action.`):u(`Local action version ${t} matches latest action version.`),m(),g("Collecting inputs"),u("commit hash");let o=F();u("repo owner");let n=I();u("Decent API key");let s=$("api-key",!0);u("app name");let r=$("app-name",!0);u("project local path");let a=_();m(),g("Preparing local dist path and version file"),u("check for dist directory");let i=wt.join(a,"dist");await H(i)||w("Local dist directory missing. Your Github workflow (e.g., .github/workflows/deploy.yml) should check out your project and build/copy to the ./dist folder all files meant for deployment."),u("write version file"),await L(o,i),m(),g("Preparing files for upload");async function p(f){let d=c[f];if(d!=="")try{u(`upload ${d}`),await Y(n,s,r,o,i,d),c[f]="",++x}catch(tt){console.warn(`Failed to upload file ${d}: ${tt.message}.`)}}u("find files at local dist path");let c=await q(i);c.length===1&&y("No files found in ./dist directory besides version.txt. Is your project building to ./dist?"),u("prepare upload tasks");let h=c.map((f,d)=>()=>p(d));m(),g(`Uploading ${h.length} files`);let x=0,b=3,Q=10;for(let f=0;f<b;++f){f>0&&console.warn(`Retrying after failed uploads... (${f+1}/${b})`);try{if(await T(h,Q),x===c.length)break}catch(d){d(`Unexpected error while uploading files: ${d.message}.`)}}x<c.length&&(x===0&&w("Failed to upload any files. See previous warnings for details."),w(`Failed to upload all files. Only ${x} of ${c.length} files were uploaded successfully. See previous warnings for details.`)),m(),g("Updating stage index"),u("fetch app versions");let{productionVersion:S,rollbackVersion:E}=await j(r);u(`uploading new stage index - stage version=${o}, production version=${S}, rollback version=${E}`),await z(n,s,r,o,S,E,!1),m();let Z=`https://decentapps.net/_${r}/${o}/`;A(`Successfully deployed ${x} files to ${Z}.`)}catch(t){let o=!k()||t.name==="ExpectedError"?t.message:"An unexpected error occurred.";w(o)}}yt();
